/*
spawn( String entityname, [ String keyname1 ], [ String value1 ], [ String keyname2 ], [ String value2 ], [ String keyname3 ], [ String value3 ], [ String keyname4 ], [ String value4 ] )

    Spawns an entity.
*/
//=========================================================================
main: {
//=========================================================================
    if(level.spawnerPrecached == 1) { end }
    level.spawnerPrecached = 1

    if(level.spawnerActivated == 0 || level.spawnerActivated == NIL) { end }
    
    iprintlnbold_noloc("Spawner executed!")
    level.spawnerUpdateDist = 1000
    level.spawnerStop       = 0
    level.updateInteger     = 1
    level.spawnerInterval   = 2
    level.spawnerRotations  = 5


    level.map = getcvar("mapname")
    thread script_master
}end

//=========================================================================
script_master: { 
//=========================================================================
    //setup spawner
    level waittill spawn
    local.models = exec coop_mod/spawner/enemy_models.scr::level.map
    local.spawner = exec coop_mod/spawner/enemy_spawnlocations.scr::level.map

    while(1) {
        local.player = waitthread get_players
        local.distance = vector_length(local.player.origin - local.spawner)

        if(waitthread update_existence_check) {
            if(local.distance > level.spawnerUpdateDist){
                iprintlnbold_noloc("Spawner Update!")
                local.spawnerNew = (level.map + "_update" + level.updateInteger)
                local.spawner = exec coop_mod/spawner/enemy_spawnlocations.scr::local.spawnerNew
                level.updateInteger++
            }
        }
        else {
            if(local.distance < level.spawnerUpdateDist && level.spawnerStop == 0) {
                iprintlnbold_noloc("Spawner Stopping!")
                level.spawnerStop = 1
            }
        }

        // check if at least one german was alarmed or if alarms are triggered
        local.alarmedEnemies = waitthread is_alarmed
        if(level.spawnerStop == 0 && local.alarmedEnemies >= 3 || level.alarm_on == 1) {
            iprintlnbold_noloc("Spawner Rolling!")

            if !(local.player cansee local.spawner 80) {
                for(local.i = 1; local.i <= level.spawnerRotations; local.i++){
                    spawn "models/human/german_afrika_officer.tik" targetname "spawner_enemy" origin local.spawner
                    $spawner_enemy attackplayer
                    wait level.spawnerInterval
                }
            }
        }
        waitframe
    }
}end

//=========================================================================
is_alarmed: {
//=========================================================================
   local.angryGerman = 0
   
    for(local.i = 1; local.i <= level.coop_actorArray["german"].size; local.i++){
        local.german = level.coop_actorArray["german"][local.i]
        if(local.german != NULL && local.german != NIL && local.german.thinkstate == "attack") {
            local.angryGerman += 1
        }
    }
}end local.angryGerman

//=========================================================================
get_players: {
//=========================================================================
    local.player = NULL

    for(local.i = 1; local.i <= $player.size; local.i++) {
        if($player[local.i] != NIL && $player[local.i] != NULL && $player[local.i].dmteam != "spectator" && $player[local.i].health > 0){
            local.player = $player[local.i]
        }
    }
}end local.player

//=========================================================================
update_existence_check: {
//=========================================================================
    if(local.updateChecked == 0) {
        local.temp1 = (level.map + "_update" + level.updateInteger)
        local.origin = exec coop_mod/spawner/enemy_spawnlocations.scr::local.temp1
        local.updateChecked = 1
        
        if(local.origin == NIL || local.origin == NULL) {
            end 0
        }
        else {
            end 1
        }
    }
} end NULL